### JRE与JDK
* JRE java运行环境，和java程序所需的核心类库，如果想要运行好一个开发好的java程序,计算机中只需要安装JRE即可
* JDK java开发工具包
* JDK是提供给java开发人员使用的,其中包含了java的开发工具也包含了JRE，所以安装了JDK，就不用单独安装JRE了,其中的开发工具：编译工具(javac.exe),打包工具(jar.exe)等
* 简单而言：使用JDK开发完成的java程序，交给JRE去运行
* 简而言之：
	* JRE：JVM+类库
	* JDK：JRE+JAVA的开发工具 

### JDK安装路径下的目录
* bin:该目录用于存放一些可执行程序
	* javac.exe java编译器
	* java.exe java运行工具
	* javadoc.exe 文档生成工具
* db:db目录是一个小型的数据库，从jdk6.0开始，java中引用了一个新成员javaDB,这是一个纯java实现、开元的数据库管理系统，这个数据库不仅轻便，而且支持JDBC4.0的所有规范,在学习JDBC时候，不需要额外安装数据库软件，直接选择javaDB即可
* jre:java运行环境，此目录是java运行时环境的根目录，它包含java虚拟机,运行时类包，java应用启动器以及一个bin目录，但不包含开发环境中的开发工具
* inclide:由于JDK是通过C和C++实现的，因此在启动的时候需要引入一些C语言的头文件，该目录就是用于存放这些头文件的
* lib:library的缩写，意为java类库或库文件，是开发工具使用的归档包文件
* src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码,通过该文件可以查看java基础类的源代码

### 任意进制到十进制互转
```
System.out.println(0b100);			//二进制表示形式前面加0b(b可以大写也可以小写)
System.out.println(0100);			//八进制表示形式前面加0
System.out.println(100);
System.out.println(0x100);			//十六进制表示形式前面加0x
```
* 基数：转换为X进制，基数就是X
* 权：自右向左从0开始数字依次递增编号
* 结果：系数*基数的全次幂


### 反码与补码
* 源码
	* 二进制定点表示法，最高位为符号位，0表示正，1表示负；其余位表示数值大小
	* 通过一个字节，也就是8个二进制位表示+7和-7
	* 0(符号位) 0000111
	* 1(符号位) 0000111
* 反码
	* 正数的反码与其源码相同
	* 负数的反码是对原码逐位取反，但符号位除外
* 补码
	* 正数的补码与其原码相同
	* 负数的补码是在其反码的末尾加1

### 数据类型转换
* 隐式转换
	* 小的数据类型和大的数据类型机型运算时，小的数据类型会自动转换为大的数据类型    
* 强制转换
	```
		int x = 3;
		byte b = 4;
		b = (byte) (x + b);
		System.out.println(b);
	``` 
* 强制转换超出范围
	```
		byte b = (byte)(126+4);
		System.out.println(b);				//-126

	
		/*
			130  -> 00000000 00000000 000000000 10000010
			当去掉前三个8位的时候就成了 10000010  -> -126补码
									 10000001  -> 减1求-126反码
								     11111110  -> -126的原码
		*/		

		byte b2 = (byte)300;
		System.out.println(b2);				//44

		/*
			300   ->   0000000 0000000 00000001 00101100
			当去掉前三个8位的时候就成了 00101100  -> 44的补码
										    
			
		*/
        			

	```
### 面试题
```
	//看下面的程序是否有问题，如果有问题，请指出并说明理由
	byte b1 = 3;
	byte b2 = 4;
	byte b3 = b1 + b2;
	System.out.println(b3);

	/*
		解释1：byte和byte(short,char)进行运算的时候会提升为Int,两个int相加的结果也是int类型
		解释2：b1和b2是两个变量，变量存储的值是变化的，在编译的时候无法判断里面具体得到值，相加有可能会超出bute的取值范围
	*/

	byte b4 = 3 + 4;			//java编译器有常量优化机制
	System.out.println(b4);

```

### long与float取值范围比较
* 进行混合运算的时候,byte,short,char不会相互转换，都会自动提升为int，其他类型进行混合运算的是小的类型提升为大的
* byte,short,char -> int -> long ->float -> fouble
* long:8字节
* float：4字节
* 4字节是32个二进制位，一位是符号位，8位是指数位，23位是尾数位
```
//看下面得到程序是否有问题，有问题，请指出
short s=1; s=s+1;		//编译出错，当short与int进行运算时，会提升为int
short ss=1;ss+=1;		//正常   s = (short)(s+1);
```


### 数组
	* 数组的定义
	```
		//动态初始化
		int[] arr = new int[5];
		
		/*
		左边:
			int : 数据类型
			[]  : 代表的数组，几个中括号就是几位数组
			arr : 合法的标识符
		右边：
			new : 创建新的实体或对象
			int : 数据类型
			[]  : 代表的数组
			 5  : 代表数组的长度
		*/
		//静态初始化
		/*
		格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2};
		简化格式：数据类型[] 数组名 = {元素1,元素2}; //声明和赋值必须在同一行
		*/
		
		//可行
		int[] arr;
		arr = new int[]{11,22,33,44,55};
		
 		//不可行,简写形式，声明和赋值必须在同一行
		int[] arr2;
		arr2 = {11,22,33,44,55};

	```
	* 整数类型：byte,short,int,long默认初始化值都是0
	* 浮点类型：float,double默认初始化值都是0.0
	* 布尔类型：boolean默认初始化值false
	* 字符类型：char默认初始化值'\u0000'
	* 内存划分：
		* 栈：存储局部变量
		* 堆：存储new出来的数组或对象
		* 方法区：面向对象部分讲解
		* 寄存器：给CPU使用 


### static关键字
* 未加静态
![](http://yingxs.com/img/javase_static1.png)
* 加静态
![](http://yingxs.com/img/javase_static2.png)

### static关键字的特点
* 随着类的加载而加载
* 优先于对象存在
* 被类的所有对象共享
* 可通过类名调用 
	* 静态修饰的内容一般称其为:与类相关的，类成员，类方法 
* 共享用静态，特性用非静态

### static静态的注意事项
* 在静态方法中是没有this关键字的
	* 静态是随着类的加载而加载，this是随着对象的创建而存在 
	* 静态比对象先存在
* 静态方法只能访问静态的成员变量和静态的成员方法
	*  静态只能访问静态

### 静态变量和成员变量的区别
* 静态变量也叫类变量 成员变量也叫对象变量
* 所属不同
	* 静态变量属于类，所以也称为类变量
	* 成员变量属于对象，所以也称为对象变量或者实例变量
* 内存中位置不同
	* 静态变量存储于方法区的静态区
	* 成员变量存储于堆内存
* 内存出现的时间不同
	* 静态变量随着类的加载而加载，随着类的消失而消失
	* 成员变量随着对象的创建而存在，随着对象的小时而消失
* 调用不同
	* 静态变量可以通过类名调用，也可以通过对象调用
	* 成员变量只能通过对象名调用    
	

### main的详细解释